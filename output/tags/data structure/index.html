<!DOCTYPE html><html lang="en"><head>
    <meta charset="utf-8">
    <title>A Developer's Notebook - </title>
    <link rel="stylesheet" href="https://unpkg.com/purecss@1.0.1/build/pure-min.css" integrity="sha384-oAOxQR6DkCoMliIh8yFnu25d7Eq/PHS21PClpwjOTeU2jRSq11vu66rf90/cZr47" crossorigin="anonymous">
    <link rel="stylesheet" href="../../assets/stylesheet.css">
    <link rel="stylesheet" href="../../assets/highlight.css">

    <!-- you don't need to keep this, but it's cool for stats! -->
    <meta name="generator" content="Nanoc 4.11.9">
  </head>
  <body>
    <div id="layout">
      <div class="header">
        <h1>
          <a href="../../">A Developer's Notebook</a>
        </h1>
      </div>


      <div class="content">
        <nav class="pure-g">
          <div class="pure-u-2-3 links">
            <a href="../../index.html">Home</a> ·
            <a href="../../tags.html">Tags</a> ·
            <a href="../../years.html">Years</a> ·
            <a href="../../about.html">About</a>
          </div>

          <div class="pure-u-1-3">
            <div class="contact">
              <span>
                <a href="https://github.com/lbrito1" download="">
                  <img src="../../assets/icons/github.svg" alt="Github icon">
                  </a>
              </span>
              <span>
                <a href="https://www.linkedin.com/in/leonardo-mendes-brito/">
                <img src="../../assets/icons/linkedin.svg" alt="LinkedIn icon">
                </a>
              </span>
            </div>
          </div>
        </nav>
        
  <h1>Posts tagged "data structure"</h1>

  <div class="pure-g">
  
    <div class="post-index pure-u-1-1">
      <h2><a href="../../2014/03/heap-priority-queues.html">Heap &amp; Priority Queues</a></h2>

      <article class="text">
          <p>Priority queues (PQs) are abstract data types that work just like regular stacks, but the popping order depends on each element’s priority instead of the sequence they were pushed onto the queue (FIFO or LIFO).</p>

<p>The naïve way of implementing a PQ consists of using an unsorted list or array and searching for the highest-priority element at each pop, which takes O(n) time. There are several more efficient implementations, of which the most usual is the heap.</p>

<p>Heaps are complete (i.e. all levels except possibly the last are filled) binary trees that work as PQs by maintaining the following property: children nodes always have a smaller priority than their parent, i.e. for any node A with children B and C, priority(B) &lt; priority(A) &amp;&amp; priority(C) &lt; priority(A). Note that there is no assumed relation between siblings or cousins.</p>

<p><a href="../../assets/images/codedeposit/2014/03/heap.jpg"><img src="../../assets/images/codedeposit/2014/03/heap.jpg" alt="max-heap and corresponding array."></a>
<em>max-heap and corresponding array.</em></p>

<p>Each element of a heap has two pieces of information: a key and a value, hence we call them key-value (KV) pair. The key identifies the specific element, and the value determines the element’s priority within the heap. Heaps can be min-heaps (low value = high priority) or max-heaps (high value = high priority).</p>


        <div class="post-tags">
          
        </div>

        <div class="pure-g post-footer">
          <div class="pure-u-1-2">
              <a class="read-more" href="../../2014/03/heap-priority-queues.html">Continue reading ›</a>
          </div>
          <div class="pure-u-1-2 post-meta">
            <aside>Posted Mar 21, 2014</aside>

          </div>
        </div>
      </article>
    </div>
  
    <div class="post-index pure-u-1-1">
      <h2><a href="../../2014/03/trees-part-i.html">Trees - Part I</a></h2>

      <article class="text">
          <p><a href="../../assets/images/codedeposit/2014/03/tree1.jpg"><img src="../../assets/images/codedeposit/2014/03/tree1.jpg" alt="tree"></a></p>

<p><a href="http://commons.wikimedia.org/wiki/File%3ABright_green_tree_-_Waikato.jpg"><img src="//upload.wikimedia.org/wikipedia/commons/thumb/f/f6/Bright_green_tree_-_Waikato.jpg/512px-Bright_green_tree_-_Waikato.jpg" alt="Bright green tree - Waikato"></a></p>

<p>We used trees to build the <a href="%7B%%20link%20_posts/2014-03-21-heap-priority-queues.markdown%20%%7D">heap data structure</a> before, but we didn’t bother with the theory behind trees, which are abstract and concrete data structures themselves. There’s a huge range of material to cover so I’ll split this in several posts.</p>

<p>In this first post we’ll cover the basic theory and implement a binary search tree (BST), which provides <code>O(h)</code> time search, insert and delete operations (<code>h</code> is the tree height). First, the basics:</p>

<p>Trees are graphs with a few extra properties and interpretations/conventions.
* Trees have height (longest branch length) and depth (distance to root).
* The uppermost level consists of at most one node (the tree root).
* All nodes may have children.
* There are no edges other than parent-child edges.</p>

<p>Trees are classified according to some&nbsp;of those properties above and some others we’ll mention later. Most commonly, there is a constraint to the maximum number of children per node -e.g. the binary tree limits children to 2 per node.

        </p><div class="post-tags">
          
        </div>

        <div class="pure-g post-footer">
          <div class="pure-u-1-2">
              <a class="read-more" href="../../2014/03/trees-part-i.html">Continue reading ›</a>
          </div>
          <div class="pure-u-1-2 post-meta">
            <aside>Posted Mar 31, 2014</aside>

          </div>
        </div>
      </article>
    </div>
  
    <div class="post-index pure-u-1-1">
      <h2><a href="../../2014/03/graph.html">Graph</a></h2>

      <article class="text">
          <p>Mathematically, a graph is a set of vertices and edges, thus a graph <code>G</code> is usually written as <code>G(V,E)</code>. Besides linking vertices in the graph, edges can also carry a specific value which may be interpreted as cost, weight, distance etc.</p>

<p><a href="../../assets/images/codedeposit/2014/03/graph1.jpg"><img src="../../assets/images/codedeposit/2014/03/graph1.jpg" alt="graph viewed with BurgerGFX"></a></p>

<p>In computer science, we’re interested in the (abstract) data structure used to implement the graph mathematical concept. Let’s first discuss the basic elements in a graph - vertices and edges:</p>

<div class="highlight"><pre><code class="language-c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">vertex</span>
<span class="p">{</span>
 <span class="kt">unsigned</span> <span class="kt">long</span> <span class="n">id</span><span class="p">;</span>
 <span class="kt">int</span> <span class="n">status</span><span class="p">;</span>
 <span class="kt">double</span> <span class="n">x</span><span class="p">,</span><span class="n">y</span><span class="p">;</span>
 <span class="kt">void</span><span class="o">*</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span> <span class="n">vertex</span><span class="p">;</span></code></pre></div>

<p>Vertices should be able to hold any kind of data, so we’ll just throw in a void pointer for that. Other than that we have an id, status (marked or unmarked - more on that later) and 2D coordinates so we can draw the vertices somewhere.</p>

<div class="highlight"><pre><code class="language-c"><span class="k">typedef</span> <span class="k">struct</span> <span class="n">edge</span>
<span class="p">{</span>
 <span class="n">vertex</span><span class="o">*</span> <span class="n">from</span><span class="p">,</span> <span class="o">*</span><span class="n">to</span><span class="p">;</span>
 <span class="kt">int</span> <span class="n">cost</span><span class="p">;</span>
<span class="p">}</span> <span class="n">edge</span><span class="p">;</span></code></pre></div>

<p>Edges consist of just pointers to the vertices they link and an optional value used as weight, distance, cost etc. Strictly speaking we could use a void pointer for that value as well, as long as we also defined a comparison function. But let’s save the hassle and just use an integer instead - most algorithms will be fine with that.</p>


        <div class="post-tags">
          
        </div>

        <div class="pure-g post-footer">
          <div class="pure-u-1-2">
              <a class="read-more" href="../../2014/03/graph.html">Continue reading ›</a>
          </div>
          <div class="pure-u-1-2 post-meta">
            <aside>Posted Mar 23, 2014</aside>

          </div>
        </div>
      </article>
    </div>
  
    <div class="post-index pure-u-1-1">
      <h2><a href="../../2014/04/trees-part-ii-avl-tree.html">Trees, Part II: AVL Tree</a></h2>

      <article class="text">
          <p>Masters classes started a few weeks ago, taking their&nbsp;toll on my productivity here. Sorry about that!</p>

<p>So we (pardon the&nbsp;<a href="http://en.wikipedia.org/wiki/Nosism">nosism</a>, but I think it sounds less egocentric&nbsp;than writing “I” all the time) hinted at AVL trees back on our <a href="%7B%%20link%20_posts/2014-03-31-trees-part-i.markdown%20%%7D">Trees, Part I</a>&nbsp;post. Specifically, we learned that:</p>

<blockquote>a binary search tree (BST), provides O(h) time search, insert and delete operations (h is the tree height.</blockquote>

<p>Linear time (O(h)) doesn’t sound very good - if h is close to n, we’ll have the same performance as a <a href="%7B%%20link%20_posts/2014-02-14-3.markdown%20%%7D%7D">linked list</a>.&nbsp;What if there were a way to&nbsp;bound the tree height&nbsp;to some sub-linear factor? As it turns out, there are several ways to do so, and the general idea of somehow&nbsp;keeping the tree height limited to a certain factor of the number of elements it holds is called height&nbsp;<strong>balancing</strong>. Ergo we’ll want to look into (height)&nbsp;<strong>balanced/self-balancing binary search trees **(BBST)</strong>.&nbsp;**</p>

<div class="highlight"><pre><code class="language-bash">                      Burger


                          M
                        <span class="nb">.</span>   <span class="nb">.</span>
                      <span class="nb">.</span>       <span class="nb">.</span>
                    <span class="nb">.</span>           <span class="nb">.</span>
                  <span class="nb">.</span>               <span class="nb">.</span>
                E <span class="nb">.</span>                 P <span class="nb">.</span>
              <span class="nb">.</span>     <span class="nb">.</span>                   <span class="nb">.</span>
            <span class="nb">.</span>         <span class="nb">.</span>                   <span class="nb">.</span>
          <span class="nb">.</span>             <span class="nb">.</span>                   <span class="nb">.</span>
      D <span class="nb">.</span>                 I                   Y
                        <span class="nb">.</span>
                      <span class="nb">.</span>
                    <span class="nb">.</span>
                  <span class="nb">.</span>
                F</code></pre></div>

<p><em>AVL tree</em></p>

<p>Since binary search trees have at most two children, the best tree height (i.e. smallest) we can achieve is log2 n (n being the number of elements in the tree). There are <a href="http://en.wikipedia.org/wiki/Self-balancing_binary_search_tree">several </a>self-balancing BSTs developed over the years. It seems that up there in the US college professors&nbsp;tend to prefer the red-black tree when studying BBSTs, whilst over here AVL is preferred. In any case, AVL tree was&nbsp;the first BBST ever devised, so we’ll adopt it as our BBST model.</p>

<p>AVL trees (named after its two Soviet inventors Adelson-Velsky and Landis) use a series of <strong>rotations</strong> to keep the tree balanced. To keep track of when a certain subtree rooted at some node needs to be rotated, we maintain (or calculate) a&nbsp;<strong>balance factor</strong> variable for each node, which is the difference between the node’s left and right children’s heights, i.e.:</p>

<p>balance_factor(n) = n.left_child.height - n.right_child.height</p>


        <div class="post-tags">
          
        </div>

        <div class="pure-g post-footer">
          <div class="pure-u-1-2">
              <a class="read-more" href="../../2014/04/trees-part-ii-avl-tree.html">Continue reading ›</a>
          </div>
          <div class="pure-u-1-2 post-meta">
            <aside>Posted Apr 21, 2014</aside>

          </div>
        </div>
      </article>
    </div>
  
    <div class="post-index pure-u-1-1">
      <h2><a href="../../2014/02/linked-list.html">Linked List</a></h2>

      <article class="text">
          <p>Here’s a very simple implementation of the linked list data structure.</p>

<p>A pointer to the head element is enough to define a linked list. Each element consists of one pointer to the subsequent element in the list and one pointer to the element’s data:</p>

<p><a href="../../assets/images/codedeposit/2014/02/linkedlist.png"><img src="../../assets/images/codedeposit/2014/02/linkedlist.png?w=450" alt="linkedlist"></a></p>


        <div class="post-tags">
          
        </div>

        <div class="pure-g post-footer">
          <div class="pure-u-1-2">
              <a class="read-more" href="../../2014/02/linked-list.html">Continue reading ›</a>
          </div>
          <div class="pure-u-1-2 post-meta">
            <aside>Posted Feb 14, 2014</aside>

          </div>
        </div>
      </article>
    </div>
  
    <div class="post-index pure-u-1-1">
      <h2><a href="../../2014/02/vector.html">Vector</a></h2>

      <article class="text">
          <p>Very simple Vector implementation with add, add_all, get and delete operations using arrays of void pointers.</p>

<p>The downside to this as compared to simply using an array is that here we have an <em>array of pointers</em>, which means the data will most likely be scattered over the memory, not coalesced.</p>


        <div class="post-tags">
          
        </div>

        <div class="pure-g post-footer">
          <div class="pure-u-1-2">
              <a class="read-more" href="../../2014/02/vector.html">Continue reading ›</a>
          </div>
          <div class="pure-u-1-2 post-meta">
            <aside>Posted Feb 21, 2014</aside>

          </div>
        </div>
      </article>
    </div>
  
    <div class="post-index pure-u-1-1">
      <h2><a href="../../2014/03/doubly-linked-list.html">Doubly linked list</a></h2>

      <article class="text">
          <p>A doubly linked list is like our previously implemented Linked List, but instead of only having pointers to the next element, it also has pointers to the _previous _element:</p>

<p><a href="../../assets/images/codedeposit/2014/03/610px-doubly-linked-list-svg.png"><img src="../../assets/images/codedeposit/2014/03/610px-doubly-linked-list-svg.png" alt="610px-Doubly-linked-list.svg"></a></p>

<p>This property makes the doubly linked list very useful as a base for other data structures such as the stack: having a previous pointer means we can quickly (O(1)) remove objects from the list’s tail, which would be impossible with a linked list.</p>

<p>We won’t discuss implementation since it so similar to a linked list. If anything implementation is even simpler than a linked list because of the previous pointer access.</p>


        <div class="post-tags">
          
        </div>

        <div class="pure-g post-footer">
          <div class="pure-u-1-2">
              <a class="read-more" href="../../2014/03/doubly-linked-list.html">Continue reading ›</a>
          </div>
          <div class="pure-u-1-2 post-meta">
            <aside>Posted Mar 18, 2014</aside>

          </div>
        </div>
      </article>
    </div>
  
    <div class="post-index pure-u-1-1">
      <h2><a href="../../2014/03/stack.html">Stack</a></h2>

      <article class="text">
          <p>Using our implementation of a doubly linked (DL) list, we can very simply build the most basic LIFO (last in, first out) data structure: the stack.</p>

<p><a href="../../assets/images/codedeposit/2014/03/stack.png"><img src="../../assets/images/codedeposit/2014/03/stack.png?w=300" alt="stack"></a></p>

<p>Stacks have two basic operations: push and pop. Push pushes data onto the stack (i.e., end of the DL list) and pop pops data off the list’s tail, which is only possible because we can set the new tail as tail-&gt;prev, since we’re using a DL list, with previous pointers. Another useful function is peek, which returns a pointer to the stack’s top.</p>


        <div class="post-tags">
          
        </div>

        <div class="pure-g post-footer">
          <div class="pure-u-1-2">
              <a class="read-more" href="../../2014/03/stack.html">Continue reading ›</a>
          </div>
          <div class="pure-u-1-2 post-meta">
            <aside>Posted Mar 18, 2014</aside>

          </div>
        </div>
      </article>
    </div>
  
</div>


        <div class="footer">
          2019 Leonardo Brito
        </div>
      </div>

    </div>
  


</body></html>