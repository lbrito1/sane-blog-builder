<!DOCTYPE html><html lang="en"><head>
    <meta charset="utf-8">
    <title>A Developer's Notebook - </title>
    <link rel="stylesheet" href="https://unpkg.com/purecss@1.0.1/build/pure-min.css" integrity="sha384-oAOxQR6DkCoMliIh8yFnu25d7Eq/PHS21PClpwjOTeU2jRSq11vu66rf90/cZr47" crossorigin="anonymous">
    <link rel="stylesheet" href="../../assets/stylesheet.css">
    <link rel="stylesheet" href="../../assets/highlight.css">

    <!-- you don't need to keep this, but it's cool for stats! -->
    <meta name="generator" content="Nanoc 4.11.9">
  </head>
  <body>
    <div id="layout">
      <div class="header">
        <h1>
          <a href="../../">A Developer's Notebook</a>
        </h1>
      </div>


      <div class="content">
        <nav class="pure-g">
          <div class="pure-u-2-3 links">
            <a href="../../index.html">Home</a> ·
            <a href="../../tags.html">Tags</a> ·
            <a href="../../years.html">Years</a> ·
            <a href="../../about.html">About</a>
          </div>

          <div class="pure-u-1-3">
            <div class="contact">
              <span>
                <a href="https://github.com/lbrito1" download="">
                  <img src="../../assets/icons/github.svg" alt="Github icon">
                  </a>
              </span>
              <span>
                <a href="https://www.linkedin.com/in/leonardo-mendes-brito/">
                <img src="../../assets/icons/linkedin.svg" alt="LinkedIn icon">
                </a>
              </span>
            </div>
          </div>
        </nav>
        
  <h1>Posts tagged "abstract data structure"</h1>

  <div class="pure-g">
  
    <div class="post-index pure-u-1-1">
      <h2><a href="../../2014/03/heap-priority-queues.html">Heap &amp; Priority Queues</a></h2>

      <article class="text">
          <p>Priority queues (PQs) are abstract data types that work just like regular stacks, but the popping order depends on each element’s priority instead of the sequence they were pushed onto the queue (FIFO or LIFO).</p>

<p>The naïve way of implementing a PQ consists of using an unsorted list or array and searching for the highest-priority element at each pop, which takes O(n) time. There are several more efficient implementations, of which the most usual is the heap.</p>

<p>Heaps are complete (i.e. all levels except possibly the last are filled) binary trees that work as PQs by maintaining the following property: children nodes always have a smaller priority than their parent, i.e. for any node A with children B and C, priority(B) &lt; priority(A) &amp;&amp; priority(C) &lt; priority(A). Note that there is no assumed relation between siblings or cousins.</p>

<p><a href="../../assets/images/codedeposit/2014/03/heap.jpg"><img src="../../assets/images/codedeposit/2014/03/heap.jpg" alt="max-heap and corresponding array."></a>
<em>max-heap and corresponding array.</em></p>

<p>Each element of a heap has two pieces of information: a key and a value, hence we call them key-value (KV) pair. The key identifies the specific element, and the value determines the element’s priority within the heap. Heaps can be min-heaps (low value = high priority) or max-heaps (high value = high priority).</p>


        <div class="post-tags">
          
        </div>

        <div class="pure-g post-footer">
          <div class="pure-u-1-2">
              <a class="read-more" href="../../2014/03/heap-priority-queues.html">Continue reading ›</a>
          </div>
          <div class="pure-u-1-2 post-meta">
            <aside>Posted Mar 21, 2014</aside>

          </div>
        </div>
      </article>
    </div>
  
    <div class="post-index pure-u-1-1">
      <h2><a href="../../2014/03/trees-part-i.html">Trees - Part I</a></h2>

      <article class="text">
          <p><a href="../../assets/images/codedeposit/2014/03/tree1.jpg"><img src="../../assets/images/codedeposit/2014/03/tree1.jpg" alt="tree"></a></p>

<p><a href="http://commons.wikimedia.org/wiki/File%3ABright_green_tree_-_Waikato.jpg"><img src="//upload.wikimedia.org/wikipedia/commons/thumb/f/f6/Bright_green_tree_-_Waikato.jpg/512px-Bright_green_tree_-_Waikato.jpg" alt="Bright green tree - Waikato"></a></p>

<p>We used trees to build the <a href="%7B%%20link%20_posts/2014-03-21-heap-priority-queues.markdown%20%%7D">heap data structure</a> before, but we didn’t bother with the theory behind trees, which are abstract and concrete data structures themselves. There’s a huge range of material to cover so I’ll split this in several posts.</p>

<p>In this first post we’ll cover the basic theory and implement a binary search tree (BST), which provides <code>O(h)</code> time search, insert and delete operations (<code>h</code> is the tree height). First, the basics:</p>

<p>Trees are graphs with a few extra properties and interpretations/conventions.
* Trees have height (longest branch length) and depth (distance to root).
* The uppermost level consists of at most one node (the tree root).
* All nodes may have children.
* There are no edges other than parent-child edges.</p>

<p>Trees are classified according to some&nbsp;of those properties above and some others we’ll mention later. Most commonly, there is a constraint to the maximum number of children per node -e.g. the binary tree limits children to 2 per node.

        </p><div class="post-tags">
          
        </div>

        <div class="pure-g post-footer">
          <div class="pure-u-1-2">
              <a class="read-more" href="../../2014/03/trees-part-i.html">Continue reading ›</a>
          </div>
          <div class="pure-u-1-2 post-meta">
            <aside>Posted Mar 31, 2014</aside>

          </div>
        </div>
      </article>
    </div>
  
    <div class="post-index pure-u-1-1">
      <h2><a href="../../2014/03/stack.html">Stack</a></h2>

      <article class="text">
          <p>Using our implementation of a doubly linked (DL) list, we can very simply build the most basic LIFO (last in, first out) data structure: the stack.</p>

<p><a href="../../assets/images/codedeposit/2014/03/stack.png"><img src="../../assets/images/codedeposit/2014/03/stack.png?w=300" alt="stack"></a></p>

<p>Stacks have two basic operations: push and pop. Push pushes data onto the stack (i.e., end of the DL list) and pop pops data off the list’s tail, which is only possible because we can set the new tail as tail-&gt;prev, since we’re using a DL list, with previous pointers. Another useful function is peek, which returns a pointer to the stack’s top.</p>


        <div class="post-tags">
          
        </div>

        <div class="pure-g post-footer">
          <div class="pure-u-1-2">
              <a class="read-more" href="../../2014/03/stack.html">Continue reading ›</a>
          </div>
          <div class="pure-u-1-2 post-meta">
            <aside>Posted Mar 18, 2014</aside>

          </div>
        </div>
      </article>
    </div>
  
</div>


        <div class="footer">
          2019 Leonardo Brito
        </div>
      </div>

    </div>
  


</body></html>